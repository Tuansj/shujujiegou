总结刷题用的知识点。（查字典方式，非新手向）
这个项目专门刷力扣的题目。每个题目配上一个h和cpp文件的解决方案。在main函数中进行调用。

方法论：

理解的关键是推演能力，能否根据联系建立出整个逻辑过程。是一个从图中进行构建的方法。
联想的方法就是，脑海中问自己这个东西是什么？为什么？怎么办？

基础能力不够，庞大的问题处理不过来，超出了脑容量。
提高自己理清逻辑，和对控制的基本能力。//因为大部分的人基础能力都不强。基础能力的锤炼是要一步步的 。慢慢来。
学习更加简便的表述方法。明白更多好的api的使用。
不用这么在意有没有写出来和证明能力。我们练习的是能力，模仿的是做法，记住的是知识。用些时间这些都会成功的。关键是面对压力能不能抗住。

1.创建h文件的格式，包含关系，类，结构体，函数，变量定义。

h文件和class文件不用名字相同，C#才要。这就表明一个h文件可以有很多的类。（C#可以查查是不是不可以）

编译过程是将头文件先收集到一起，再一起编译。如果在某个头文件上打上标记，就可以让重复包含的头文件能够只编译一次。如#pragma once 和 #ifndef #define #endif
所以能否重复包含关键是这个文件有没有写东西。

cpp是用来实现局部函数的，用到的时候才编译，先看声明。的所以全局变量都定义在头文件比较好，class和结构体则必须是头文件中把变量定义和写清楚。

可以没有实现的cpp文件吗？在vs2019可以通过，只要有包含了头文件的，然后名字相同参数相同的一样函数就可以找到实现的地方。这个具体原理不清楚。

规范格式（初次编辑）：cpp和h名字相同，cpp包含h中，h文件只编译一次#pragma once。h写类型和全局变量。而 cpp中写实现和局部变量。class的函数要声明作用域。模板要实现必须在头文件中。


2.stl中vector的使用
vector的迭代器
vector<int>::iterator p;//要赋值才能用。只是表明是这种类型的。迭代器跟vector对象没关系。就是一个里面提供的方法。可以做数组，也可以做指针访问
vector<int> a;   a.end();//这个指向的是最后一个元素还要后面一个。如果到这里就会溢出。
int a,b=0;值给的是b而不是a,a还是没有被初始化。
vector的数组访问形式既可以用迭代器也可以数组自己的名字。也就是 vector<int> a{1,2};  cout<<a[0]//这个估计是运算符重载的原因;  cout<<p[0];如果用迭代器，地址改变相应下标也跟着按照加地址的形式来。



//传入参数都是指针所指向的位置
插入元素vec.insert(vec.begin()+i,a);
删除元素vec.erase(iterator);//删一个元素原来的迭代器会失效。所以要得到返回的值。ptr=vec.erase(ptr);

vector的初始化，是类似构造函数般的用法
c++的类的初始化为
https://www.cnblogs.com/arxive/p/8418187.html
new是分配内存要用指针来接。而普通的是 A a; A a();A a=b; 默认构造函数，构造函数，拷贝函数。 new的话要 A *a=new A;A *a=new A();

如果想使用字面量来初始化vector对象的话，只能考虑使用重复序列初始化及列表初始化。
https://blog.csdn.net/qq_37568748/article/details/81626726?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare

重复序列初始化：
vector<int> b(5,4);//初始化为5个4。

列表初始化：
vector<int> a{1,2,3,5,4};

拷贝初始化可以把东西复制过去。 vector<int> a

3.模板的使用方法


4.string的总结
string 的size和length 是一样的，由于历史原因。

遍历还是一样的方法 string a; a[i]就可以了。for(int i=0;i<a.size();i++){a[i];}

5.控制结构的用法
swich的用法

			switch (path[i])
			{
			case 'N':
				p->x = (--p)->x;
				p->y = (--p)->y+1;
				break;
		}

6.内存类型使用方法
typedef 名称中使用的未命名的类不能声明非静态数据成员、成员枚举或成员类以外的成员

7.写bug的原因，逻辑错误是因为抓错了关键点，联想的时候不清晰。

9.哈希表hash表：
散列表，基于数字，插入和访问都接近常数。下标和值是有联系的。地址和存的值是有联系的。所以在找值的过程中不需要去一个个找，根据值找地址就可以了。
根据值能够匹配地址。
f（val）=addr;会出现地址冲突。要放到下一个关系，这个是怎么弄？重新建立链表？根据顺序来找？冲突一个后往后面找。  是函数？ 既然都是冲突你怎么去排次序。不行的，放的时候就要个次序才可以。或者打标记。最蠢的是打标记，因为标记也占地方。标记的话就是索引表。
二次冲突的解决办法（因为没有启发，而我把我想的方法都试了一遍都不行。）（启发是什么，是把一种过程跟某种过程联系起来然后去应用）

哈希表的过程，原因意义，用法。泛型





开放地址法
链地址法。

10.
链表怎么构建？
设置点的基础上，抓住头节点。队列抓住头和尾。




11.
#define 和 typedef a name;位置是反的。define前面的那个是名字。